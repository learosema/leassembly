# Fun with AssemblyScript
-----------------------------------------------
# Introduction

Hi! I'm Lea Rosema 

I am a Junior Product Engneer at SinnerSchrader by day
and a Creative coder by night

 * [https://codepen.io/terabaud](https://codepen.io/terabaud)
 * twitter: @terabaud

------------------------------------------------
# My talk is about

* WebAssembly
* The cool things
* Its shortcomings
* having fun with it despite the shortcomings
* ...without learning a (completely) new programming language

------------------------------------------------
# So, what is WebAssembly?

* new binary executable format for the web
* Arised from emscripten
* idea of emscripten: compile "anything" to JavaScript
* gained popularity through games & emulators ported to the web

------------------------------------------------

# What is Emscripten?

* it takes LLVM bitcode (generated by a C++-like compiler)
* transpiles it to a low-level JavaScript subset, called asmJS
* problem of asmJS: huge amount of JS, slow parsing times
* solution: WASM, a binary format to the rescue 
* ...it can be decoded much faster than JS can be parsed

-------------------------------------------------

# Do I need to learn C++/Rust?

* There are more choices than just C++ or Rust
* For example, there is AssemblyScript
* it's a subset of TypeScript

--------------------------------------------------
# AssemblyScript vs TypeScript

* no `any`
* specific integer and floating point types
* `u32` for 32bit unsigned integer
* `i32` for 32bit signed integer
* `f64` for 64bit floating point numbers
* `number` is an alias to `f64`

--------------------------------------------------
# Data flow (and its shortcomings)

* WASM runs in a sandbox
* no direct access to DOM API's
* Objects cannot yet flow in and out of WASM natively
* instead, have to deal with pointers
* But AssemblyScript has a loader that does that for you

---------------------------------------------------
# Low-level Memory Access

* Going low-level can be fun 
* Good for primitive flat data structures
* You can mess in memory like in C64 times
* `load<T>` and `store<T>` is your `PEEK` and `POKE`

---------------------------------------------------
# Calling from JS

## Browser

```js
const module = WebAssembly.instantiateStreaming(
  fetch('module.wasm'), importObj);
```

## Node

```js
const module = WebAssembly.instantiate(
  fs.readFileSync('module.wasm'), importObj);
```
---------------------------------------------------
# Specify the environment

```js
const importObj = {
  env: {
    memory, table, // optional
    abort() { console.error('Oh no!'); } //required
  },
  "index": { // fileName of the module
    // functions to import from js-land
  },
  Math // additional namespaces to use from js-land
};
```
---------------------------------------------------
# Additional environment stuff

```js
// a memory space, having blocks of 64KB pages
const memory = new WebAssembly.Memory({ initial: 1 }); 

// and a function reference table for functions from js-land
const table = new WebAssembly.Table({
  initial: 0, element: 'anyfunc'
});
```

---------------------------------------------------
# DEMO-Time

* Repository: [https://terabaud.github.io/leassembly/](https://github.com/terabaud/leassembly/)
* GitHub Page: [https://terabaud.github.io/leassembly/](https://terabaud.github.io/leassembly/)

-------------------------------------------------

# To sum up

* WASM runs in a sandbox
* WASM isn't faster in all cases 
* eg. extra memcopy operations from WASM to JS-land
* There's always some JS glue code to get WASM running
* WASM is a complement of JS not a replacement

--------------------------------------------------

# Thank you :)

* Repository: [https://terabaud.github.io/leassembly/](https://github.com/terabaud/leassembly/)
* GitHub Page: [https://terabaud.github.io/leassembly/](https://terabaud.github.io/leassembly/)
