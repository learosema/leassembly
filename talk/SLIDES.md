# Fun with AssemblyScript

-----------------------------------------------

## Introduction

Hi! I'm Lea Rosema

Junior Product Engineer at SinnerSchrader by day ðŸŒž

Creative coder by night ðŸŒ™

* [https://codepen.io/terabaud](https://codepen.io/terabaud)
* twitter: @terabaud
* it's a nickname I gave myself in the 90's

-----------------------------------------------

## My talk is about

* WebAssembly
* its limitations
* getting around the limitations ðŸ”¨
* without learning a (completely) new programming language

-----------------------------------------------

## So, what is WebAssembly?

* new binary executable format for the web
* Arised from emscripten
* idea of emscripten: compile "anything" to JavaScript
* gained popularity through games & emulators ported to the web

-----------------------------------------------

## What is Emscripten?

* it takes LLVM bitcode (generated by a C++-like compiler)
* transpiles it to a low-level JavaScript subset, called asmJS
* problem of asmJS: huge amount of JS, slow parsing times
* solution: WASM, a binary format to the rescue
* can be decoded much faster than JS can be parsed

-----------------------------------------------

## Do I need to learn a new programming language?

* WebAssembly is usually not written by hand
* Most WebAssembly introductions use C++ or Rust
* There are more choices than just C++ or Rust
* For example, there is AssemblyScript
* it's a subset of TypeScript

-----------------------------------------------

## AssemblyScript Hello World ðŸ‘‹

```js
export function fib(n: i32): i32 {
  var a = 0, b = 1;
  for (let i = 0; i < n; i++) {
    let t = a + b; a = b; b = t
  }
  return b;
}
```

It's pretty much like TypeScript, right?

-----------------------------------------------

## Limitations

```js
function computeSum(arr: i32[]): i32 {
  var sum = 0;
  arr.forEach(value => {
    sum += value; // cannot find "sum"
  })
  return sum;
}
```

No closures. WASM closure spec still in the works.

-----------------------------------------------

## AssemblyScript vs TypeScript

* no `any`
* specific integer and floating point types
* `i32`, `u32` for 32bit signed/unsigned integer
* `f32`, `f64` for 32/64bit floating point numbers
* `number` is an alias to `f64`
* specific `Math` implementations (`f32`, `f64` or js Math)
* no closure functions

-----------------------------------------------

## Data flow (and its shortcomings)

* WASM runs in a sandbox
* no direct access to DOM APIs
* Objects cannot yet flow in and out of WASM natively
* instead, have to deal with pointers
* But AssemblyScript has a loader that does that for you

-----------------------------------------------

## Low-level Memory Access

* Low level memory access via `load<T>` and `store<T>` 
* Like `PEEK` and `POKE` in C64 times if you remember
* Good for primitive flat data structures

-----------------------------------------------

## Bootstrapping an AssemblyScript project

* `npm i AssemblyScript/assemblyscript`
* `npx asinit .` creates new project
* AssemblyScript goes into `assembly/` folder
* it has a `tsconfig.json` for AssemblyScript
* `npm run asbuild` compiles AssemblyScript to WASM

-----------------------------------------------

## Calling from JS

### Browser

```js
const module = await WebAssembly.instantiateStreaming(
  fetch('module.wasm'), importObj);
```

### Node

```js
const module = await WebAssembly.instantiate(
  fs.readFileSync('module.wasm'), importObj);
```

-----------------------------------------------

## Specify the environment

```js
const importObj = {
  env: {
    memory, table, // optional
    abort() { console.error('Oh no!'); } //required
  },
  "index": { // fileName of the module
    // functions to import from js-land
  },
  Math // additional namespaces to use from js-land
};
```

-----------------------------------------------

## Additional environment stuff

```js
// a memory space, having blocks of 64KB pages
const memory = new WebAssembly.Memory({ initial: 1 });

// and a function reference table for functions from js-land
const table = new WebAssembly.Table({
  initial: 0, element: 'anyfunc'
});
```

-----------------------------------------------

## DEMO-Time

Let's visit [https://webassembly.studio/](https://webassembly.studio/)

-----------------------------------------------

## More DEMO-Time

Let's paint on a canvas with AssemblyScript with a p5.js-like API:

* [https://github.com/terabaud/leassembly/](https://github.com/terabaud/leassembly/)

-----------------------------------------------

## To sum up

* WASM runs in a sandbox
* WASM isn't faster in all cases
* eg. extra memcopy operations from WASM to JS-land
* There's always some JS glue code to get WASM running
* WASM is a complement of JS not a replacement

-----------------------------------------------

## Cool projects using AssemblyScript

* [https://github.com/infamous/glas](https://github.com/infamous/glas)
* [https://github.com/petersalomonsen/javascriptmusic](https://github.com/petersalomonsen/javascriptmusic)

-----------------------------------------------

## Thank you :)

* Repository: [https://github.com/terabaud/leassembly/](https://github.com/terabaud/leassembly/)
* GitHub Page: [https://terabaud.github.io/leassembly/](https://terabaud.github.io/leassembly/)
* Slides: [https://terabaud.github.io/leassembly/talk/](https://terabaud.github.io/leassembly/talk/)
* AssemblyScript [https://docs.assemblyScript.org](https://docs.assemblyScript.org/)
* MDN [https://developer.mozilla.org/en-US/docs/WebAssembly](https://developer.mozilla.org/en-US/docs/WebAssembly)
* WebAssembly Studio: [https://webassembly.studio/](https://webassembly.studio/)
